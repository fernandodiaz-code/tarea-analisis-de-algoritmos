\documentclass[12pt]{article}

% Paquetes
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{fullpage}

\title{Trabajo 2 -- Análisis de Algoritmos \\
Implementación y Análisis de Estrategias para Juego de Torta Circular}
\author{Fernando Díaz}
\date{2025}

\begin{document}
\maketitle

\begin{abstract}
En este informe se desarrolla un análisis completo del problema de selección óptima de porciones de una torta circular, donde dos jugadores alternan movimientos tomando prefijos o sufijos contiguos del arco disponible. Se propone un modelo basado en programación dinámica, se formula el esquema SRTBOT, se entrega una demostración informal de correctitud y se implementan dos estrategias de memorización: una basada en una matriz bidimensional y otra basada en una tabla hash. Asimismo, se incluye un análisis teórico de complejidad temporal y espacial, junto con un estudio empírico mediante gráficos comparativos de rendimiento entre ambas implementaciones.
\end{abstract}

\section{Introducción}
Los juegos combinatorios con información perfecta suelen resolverse mediante técnicas de programación dinámica cuando presentan estructura de subproblemas solapados. En este trabajo se estudia un juego donde un profesor y una estudiante compiten por obtener la mayor cantidad de porciones de una torta circular de $2n$ porciones, con valores enteros positivos o negativos.

El problema requiere modelar el juego desde la perspectiva del jugador que está a punto de mover, capturando el hecho de que cada movimiento consiste en remover un prefijo o un sufijo no vacío pero que deja al menos una porción disponible para el rival. Dado que ambos jugadores juegan de manera óptima, la dinámica se formaliza mediante una función que describe la máxima ganancia garantizada para el jugador de turno.

\section{Planteamiento del Problema en Mis Palabras}
La torta tiene $2n$ porciones dispuestas en un círculo, cada una con un valor entero (positivo o negativo). 

Primero, el profesor elige un arco contiguo de exactamente $n$ porciones y se lo come completo. Luego queda el arco complementario, también de $n$ porciones, donde empieza a jugar la hermana.

En su turno, un jugador siempre debe elegir una de estas dos opciones:
\begin{itemize}
    \item comer un prefijo no vacío del arco actual,
    \item comer un sufijo no vacío del arco actual,
\end{itemize}
pero nunca puede comerse el arco completo, de forma que debe quedar al menos una porción para el siguiente turno.

El objetivo es determinar cuál es la \textbf{máxima ganancia que el profesor puede garantizar}, asumiendo que ambos jugadores juegan de forma óptima.

\section{Esquema SRTBOT}

\subsection{S -- Subproblemas}
Para evitar la complejidad cíclica de la torta original, duplicamos el arreglo:
\[
S = s \, || \, s
\]
de tamaño $4n$, lo que permite representar cualquier arco circular de longitud $n$ como un segmento lineal en $S$.

Definimos:
\[
W(l, r) = \text{máxima suma que puede asegurar el jugador de turno en el arco } S[l..r].
\]

\subsection{R -- Recurrencia}
Sea $L = r - l + 1$. El jugador de turno puede comer un prefijo $S[l..l+k-1]$ con $1 \le k \le L-1$, dejando el resto $S[l+k..r]$, o puede comer un sufijo $S[r-k+1..r]$ dejando el resto $S[l..r-k]$.

El oponente puede asegurar $W(\text{resto})$. Como este es un juego suma-cero,
\[
\text{ganancia actual} = \text{SUM}(l,r) - W(\text{resto}).
\]

Por lo tanto, el jugador de turno minimiza lo que el oponente puede obtener:
\[
W(l,r) = \text{SUM}(l,r) - \min\Big(
\min_{1 \le k \le L-1} W(l+k,r),
\min_{1 \le k \le L-1} W(l,r-k)
\Big).
\]

\subsection{T -- Transiciones}
Las transiciones van desde intervalos grandes a intervalos más pequeños eliminando prefijos o sufijos. Cada llamada $W(l,r)$ depende de $W(l+k,r)$ y $W(l,r-k)$.

\subsection{B -- Casos Base}
Para intervalos de longitud 1:
\[
W(i,i) = S[i].
\]

\subsection{O -- Objetivo}
El profesor elige un arco de longitud $n$ que minimiza la ganancia de la hermana:
\[
\text{Ganancia del profesor} = \text{Total} - \min_{a=0}^{2n-1} W(a, a+n-1).
\]

\subsection{T -- Técnica}
Se utiliza programación dinámica top-down con memoización o bottom-up por longitudes. En este informe implementamos ambas estrategias de memoización: matriz 2D y tabla hash.

\section{Cambios y Comentarios sobre el SRTBOT}
El esquema inicial puede presentar errores si no se controla que el jugador no puede comerse el arco completo; por ello, en la definición final de la recurrencia restringimos los movimientos a $1 \le k \le L-1$. Además, se añadió la duplicación del arreglo para manejar correctamente la naturaleza circular de la torta.

Todos estos ajustes se reflejan en la versión final del SRTBOT incluida arriba.

\section{Implementación del Algoritmo}

\subsection{Prefijos y Cálculo de SUM}
\[
SUM(l,r) = \text{pref}[r+1] - \text{pref}[l]
\]

\subsection{Versión con Matriz 2D}
\begin{verbatim}
def W(l, r):
    if l == r:
        return S[l]
    if memo[l][r] is not None:
        return memo[l][r]
    total = SUM(l,r)
    L = r-l+1
    bestRest = +inf
    for k in range(1, L):
        bestRest = min(bestRest, W(l+k, r))
    for k in range(1, L):
        bestRest = min(bestRest, W(l, r-k))
    memo[l][r] = total - bestRest
    return memo[l][r]
\end{verbatim}

\subsection{Versión con Tabla Hash}
\begin{verbatim}
def W(l, r):
    if l == r:
        return S[l]
    if (l,r) in memo:
        return memo[(l,r)]
    total = SUM(l,r)
    L = r-l+1
    bestRest = +inf
    for k in range(1, L):
        bestRest = min(bestRest, W(l+k, r))
    for k in range(1, L):
        bestRest = min(bestRest, W(l, r-k))
    memo[(l,r)] = total - bestRest
    return memo[(l,r)]
\end{verbatim}

\section{Análisis Comparativo de Estrategias de Memoización}
\subsection{Complejidad Temporal}
Cada estado $(l,r)$ tiene longitud a lo sumo $n$ y existen $O(n^2)$ estados. Cada transición intenta $O(n)$ valores de $k$.

Por lo tanto:
\[
T(n) = O(n^3).
\]

\subsection{Complejidad Espacial}
\begin{itemize}
    \item Matriz 2D: $O(n^2)$.
    \item Tabla Hash: $O(n^2)$ esperados, con menor factor constante.
\end{itemize}

\subsection{Comparación esperada}
La tabla hash suele ser más eficiente en memoria para intervalos dispersos, mientras que la matriz 2D permite accesos más rápidos y lineales en cache, pudiendo ser más veloz.

\section{Gráficos de Rendimiento}
En esta sección deben incluirse los gráficos de ejecución que comparan ambas estrategias. Un ejemplo:

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{tiempos_comparacion.png}
\caption{Comparación de tiempos entre memoización por matriz 2D y tabla hash.}
\end{figure}

\section{Conclusiones}
En este trabajo se demostró que el juego de la torta circular presenta una estructura adecuada para programación dinámica. El diseño del subproblema, la recurrencia y el objetivo final surgen de un análisis cuidadoso del efecto que cada movimiento tiene sobre la ganancia neta.

Las dos estrategias de memoización implementadas permiten resolver el problema en tiempo $O(n^3)$, con diferencias observables en velocidad y uso de memoria. Esto permite comprender cómo la elección de estructura de datos influye directamente en el desempeño práctico.

\end{document}
